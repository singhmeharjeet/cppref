---
title: Fundamental Types
description: C++ Fundamental Types
keywords: C++, Fundamental Types
---

## C++ Fundamental Types

C++ provides a rich set of fundamental types that are used to represent various kinds of data. These types can be broadly categorized into several groups:
- **Integer Types**: These types are used to represent whole numbers. They can be signed (allowing both positive and negative values) or unsigned (only allowing non-negative values). The standard integer types include:
  - `int`: A signed integer type, typically 4 bytes.
  - `unsigned int`: An unsigned integer type, typically 4 bytes.
  - `short`: A signed short integer type, typically 2 bytes.
  - `unsigned short`: An unsigned short integer type, typically 2 bytes.
  - `long`: A signed long integer type, typically 4 or 8 bytes.
  - `unsigned long`: An unsigned long integer type, typically 4 or 8 bytes.
  - `long long`: A signed long long integer type, typically 8 bytes.
  - `unsigned long long`: An unsigned long long integer type, typically 8 bytes.
- **Floating-Point Types**: These types are used to represent real numbers (numbers with fractional parts). The standard floating-point types include:
  - `float`: A single-precision floating-point type, typically 4 bytes.
  - `double`: A double-precision floating-point type, typically 8 bytes.
  - `long double`: An extended-precision floating-point type, typically 8, 12, or 16 bytes, depending on the implementation.
- **Character Types**: These types are used to represent individual characters. The standard character types include:
  - `char`: A character type, typically 1 byte.
  - `unsigned char`: An unsigned character type, typically 1 byte.
  - `signed char`: A signed character type, typically 1 byte.
- **Boolean Type**: This type is used to represent truth values. The standard boolean type is:
  - `bool`: A boolean type that can hold the values `true` or `false`.
- **Wide Character Types**: These types are used to represent wide characters, which can represent a
  larger set of characters than the standard character type. The standard wide character types
  include:
  - `wchar_t`: A wide character type, typically 2 or 4 bytes.
- **Null Pointer Type**: This type is used to represent a null pointer. The standard null pointer type is:
  - `nullptr`: A null pointer constant that can be used to represent a null pointer of any type.
- **Void Type**: This type is used to represent the absence of a value. The standard void type is:
  - `void`: A type that represents no value. It is often used as the return type of functions that do not
	return a value.	
  - `void*`: A type that stores a memory address without specifically indicating the type of data at that address. It is often used for generic pointers.
- **Size Types**: These types are used to represent sizes and offsets in memory. The standard size types include:
  - `size_t`: An unsigned integer type used to represent the size of an object in bytes. It is typically used for array indexing and loop counters.
  - `ptrdiff_t`: A signed integer type used to represent the difference between two pointers. It is typically used for pointer arithmetic.
	
	
## What is a type?
To understand the what are types and how are they related to sizes, we need to understand the
concept of memory. Memory is just a sequence of 0s and 1s (bit). A byte is a sequence of 8 bits.

Lets say that you want to read a number from memory. And I give you the address of where the
sequence of bits is stored which represents the number. The address
represents the location of the first byte of the sequence. 

Now lets say that you get to the address and see a sequence of bits like:
```
... 00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000 ...
   ^ address points here
```

Now when you start reading the bits, you need to know how many bits to read. This is where the type comes in.
The type tells you how many bits to read. For example, if the type is `int`, you need to read 4 bytes (32 bits).
If the type is `char`, you need to read 1 byte (8 bits). If the type is `long`, you need to read 8
bytes (64 bits).

so for the same address (given above) if the value of the number read changes based on the type.

|type of number | value of the number | bits read |
|------|------------|-----------|
| char  | 0          | 1         |
| short | 0          | 2         |
| int   | 2^0 (0th index)          | 4         |
| long  | 2^16 (16th index)         | 8         |

```
... 00000000 00000000 00000000 00000001 00000000 00000000 00000000 00000000 ...
   ^--char--^ 
   ^------short------^
   ^----------------int----------------^
   ^---------------------------------long---------------------------------^
```